{"version":3,"sources":["webpack:///static/js/22.a28cf9a012b130059b37.js","webpack:///./src/components/bpm/FlowImage.vue?cbdc","webpack:///./src/assets/pinchzoom.js","webpack:///./src/components/bpm/FlowImage.vue","webpack:///./src/components/bpm/FlowImage.vue?e7cf","webpack:///./src/components/bpm/FlowImage.vue?af53","webpack:///./src/components/bpm/FlowImage.vue?cf7e","webpack:///(webpack)/buildin/amd-options.js"],"names":["webpackJsonp","1175","module","__webpack_exports__","__webpack_require__","injectStyle","ssrContext","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_1__babel_loader_node_modules_vux_loader_src_script_loader_js_node_modules_vue_loader_lib_selector_type_script_index_0_FlowImage_vue__","__WEBPACK_IMPORTED_MODULE_2__node_modules_vue_loader_lib_template_compiler_index_id_data_v_356ea82c_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vux_loader_src_before_template_compiler_loader_js_node_modules_vux_loader_src_template_loader_js_node_modules_vue_loader_lib_selector_type_template_index_0_FlowImage_vue__","normalizeComponent","__vue_styles__","Component","1407","d","PinchZoom","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from___default","n","__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__","__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default","a","target","varArgs","TypeError","to","index","arguments","length","nextSource","nextKey","prototype","hasOwnProperty","call","writable","configurable","Array","from","object","slice","buildElement","str","tmp","document","implementation","createHTMLDocument","body","innerHTML","children","triggerEvent","el","name","event","createEvent","initEvent","dispatchEvent","definePinchZoom","options","this","zoomFactor","lastScale","offset","x","y","defaults","setupMarkup","bindEvents","update","enable","sum","b","isCloseTo","expected","tapZoomFactor","zoomOutFactor","animationDuration","maxZoom","minZoom","lockDragAxis","use2d","zoomStartEventName","zoomEndEventName","dragStartEventName","dragEndEventName","doubleTapEventName","handleDragStart","stopAnimation","lastDragPosition","hasInteraction","handleDrag","touch","getTouches","drag","sanitizeOffset","handleDragEnd","end","handleZoomStart","nthZoom","lastZoomCenter","handleZoom","newScale","touchCenter","getTouchCenter","scale","handleZoomEnd","handleDoubleTap","center","startZoomFactor","updateProgress","progress","scaleTo","bind","getCurrentZoomCenter","animate","swing","maxX","getContainerX","maxY","getContainerY","maxOffsetX","Math","max","maxOffsetY","minOffsetX","min","minOffsetY","scaleZoomFactor","addOffset","originalZoomFactor","lastCenter","abs","touches","getVectorAvg","vectors","map","v","reduce","sanitize","zoomOutAnimation","isInsaneOffset","sanitizeOffsetAnimation","sanitizedOffset","targetOffset","startOffset","updateAspectRatio","setContainerY","getAspectRatio","getInitialZoomFactor","container","offsetWidth","offsetHeight","offsetLeft","offsetRight","widthOffsetRatio","centerX","height","offsetTop","offsetBottom","heightOffsetRatio","centerY","canDrag","rect","getBoundingClientRect","posTop","top","scrollTop","posLeft","left","scrollLeft","pageX","pageY","duration","framefn","timefn","callback","startTime","Date","getTime","renderFrame","inAnimation","frameTime","requestAnimationFrame","p","cos","PI","style","parentNode","insertBefore","appendChild","overflow","position","webkitTransformOrigin","mozTransformOrigin","msTransformOrigin","oTransformOrigin","transformOrigin","self","detectGestures","window","addEventListener","querySelectorAll","forEach","imgEl","nodeName","updatePlaned","setTimeout","offsetX","offsetY","transform3d","transform2d","removeClone","clone","removeChild","is3d","webkitTransform","mozTransform","msTransform","oTransform","transform","cloneNode","pointerEvents","enabled","disable","interaction","fingers","lastTouchStart","startTouches","setInteraction","newInteraction","updateInteraction","targetTouches","getDistance","sqrt","calculateScale","endTouches","startDistance","cancelEvent","stopPropagation","preventDefault","detectDoubleTap","time","firstMove","define","1432","1478","__WEBPACK_IMPORTED_MODULE_0__assets_pinchzoom_js__","data","imgUrl","created","id","$route","params","type","url","_baseUrl","$dialog","loading","open","mounted","_this","getElementById","onload","close","1532","exports","push","i","version","sources","names","mappings","file","sourcesContent","sourceRoot","1579","content","locals","1627","render","_vm","_h","$createElement","_c","_self","attrs","slot","title","href","on","click","goBack","_v","src","staticRenderFns","esExports","1662","__webpack_amd_options__"],"mappings":"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","file":"static/js/22.a28cf9a012b130059b37.js","sourcesContent":["webpackJsonp([22],{\n\n/***/ 1175:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_FlowImage_vue__ = __webpack_require__(1432);\n/* empty harmony namespace reexport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__babel_loader_node_modules_vux_loader_src_script_loader_js_node_modules_vue_loader_lib_selector_type_script_index_0_FlowImage_vue__ = __webpack_require__(1478);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__node_modules_vue_loader_lib_template_compiler_index_id_data_v_356ea82c_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vux_loader_src_before_template_compiler_loader_js_node_modules_vux_loader_src_template_loader_js_node_modules_vue_loader_lib_selector_type_template_index_0_FlowImage_vue__ = __webpack_require__(1627);\nfunction injectStyle (ssrContext) {\n  __webpack_require__(1579)\n}\nvar normalizeComponent = __webpack_require__(1)\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_1__babel_loader_node_modules_vux_loader_src_script_loader_js_node_modules_vue_loader_lib_selector_type_script_index_0_FlowImage_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_2__node_modules_vue_loader_lib_template_compiler_index_id_data_v_356ea82c_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vux_loader_src_before_template_compiler_loader_js_node_modules_vux_loader_src_template_loader_js_node_modules_vue_loader_lib_selector_type_template_index_0_FlowImage_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ 1407:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return PinchZoom; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from__ = __webpack_require__(332);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(100);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);\n\n\n/*global console, define, setTimeout, window*/\n(function () {\n    'use strict';\n\n    // polyfills\n\n    if (typeof __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default.a != 'function') {\n        // Must be writable: true, enumerable: false, configurable: true\n        Object.defineProperty(Object, \"assign\", {\n            value: function assign(target, varArgs) {\n                // .length of function is 2\n                if (target == null) {\n                    // TypeError if undefined or null\n                    throw new TypeError('Cannot convert undefined or null to object');\n                }\n\n                var to = Object(target);\n\n                for (var index = 1; index < arguments.length; index++) {\n                    var nextSource = arguments[index];\n\n                    if (nextSource != null) {\n                        // Skip over if undefined or null\n                        for (var nextKey in nextSource) {\n                            // Avoid bugs when hasOwnProperty is shadowed\n                            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                                to[nextKey] = nextSource[nextKey];\n                            }\n                        }\n                    }\n                }\n                return to;\n            },\n            writable: true,\n            configurable: true\n        });\n    }\n\n    if (typeof __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from___default.a != 'function') {\n        Array.from = function (object) {\n            return [].slice.call(object);\n        };\n    }\n\n    // utils\n    var buildElement = function buildElement(str) {\n        // empty string as title argument required by IE and Edge\n        var tmp = document.implementation.createHTMLDocument('');\n        tmp.body.innerHTML = str;\n        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from___default()(tmp.body.children)[0];\n    };\n\n    var triggerEvent = function triggerEvent(el, name) {\n        var event = document.createEvent('HTMLEvents');\n        event.initEvent(name, true, false);\n        el.dispatchEvent(event);\n    };\n\n    var definePinchZoom = function definePinchZoom() {\n\n        /**\n         * Pinch zoom\n         * @version 2.0.0\n         * @author Manuel Stofer <mst@rtp.ch>\n         * @param el\n         * @param options\n         * @constructor\n         */\n        var PinchZoom = function PinchZoom(el, options) {\n            this.el = el;\n            this.zoomFactor = 1;\n            this.lastScale = 1;\n            this.offset = {\n                x: 0,\n                y: 0\n            };\n            this.options = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()({}, this.defaults, options);\n            this.setupMarkup();\n            this.bindEvents();\n            this.update();\n            // default enable.\n            this.enable();\n        },\n            sum = function sum(a, b) {\n            return a + b;\n        },\n            isCloseTo = function isCloseTo(value, expected) {\n            return value > expected - 0.01 && value < expected + 0.01;\n        };\n\n        PinchZoom.prototype = {\n\n            defaults: {\n                tapZoomFactor: 2,\n                zoomOutFactor: 1.3,\n                animationDuration: 300,\n                maxZoom: 4,\n                minZoom: 0.5,\n                lockDragAxis: false,\n                use2d: true,\n                zoomStartEventName: 'pz_zoomstart',\n                zoomEndEventName: 'pz_zoomend',\n                dragStartEventName: 'pz_dragstart',\n                dragEndEventName: 'pz_dragend',\n                doubleTapEventName: 'pz_doubletap'\n            },\n\n            /**\n             * Event handler for 'dragstart'\n             * @param event\n             */\n            handleDragStart: function handleDragStart(event) {\n                triggerEvent(this.el, this.options.dragStartEventName);\n                this.stopAnimation();\n                this.lastDragPosition = false;\n                this.hasInteraction = true;\n                this.handleDrag(event);\n            },\n\n            /**\n             * Event handler for 'drag'\n             * @param event\n             */\n            handleDrag: function handleDrag(event) {\n                if (this.zoomFactor > 1.0) {\n                    var touch = this.getTouches(event)[0];\n                    this.drag(touch, this.lastDragPosition);\n                    this.offset = this.sanitizeOffset(this.offset);\n                    this.lastDragPosition = touch;\n                }\n            },\n\n            handleDragEnd: function handleDragEnd() {\n                triggerEvent(this.el, this.options.dragEndEventName);\n                this.end();\n            },\n\n            /**\n             * Event handler for 'zoomstart'\n             * @param event\n             */\n            handleZoomStart: function handleZoomStart(event) {\n                triggerEvent(this.el, this.options.zoomStartEventName);\n                this.stopAnimation();\n                this.lastScale = 1;\n                this.nthZoom = 0;\n                this.lastZoomCenter = false;\n                this.hasInteraction = true;\n            },\n\n            /**\n             * Event handler for 'zoom'\n             * @param event\n             */\n            handleZoom: function handleZoom(event, newScale) {\n                // a relative scale factor is used\n                var touchCenter = this.getTouchCenter(this.getTouches(event)),\n                    scale = newScale / this.lastScale;\n                this.lastScale = newScale;\n\n                // the first touch events are thrown away since they are not precise\n                this.nthZoom += 1;\n                if (this.nthZoom > 3) {\n\n                    this.scale(scale, touchCenter);\n                    this.drag(touchCenter, this.lastZoomCenter);\n                }\n                this.lastZoomCenter = touchCenter;\n            },\n\n            handleZoomEnd: function handleZoomEnd() {\n                triggerEvent(this.el, this.options.zoomEndEventName);\n                this.end();\n            },\n\n            /**\n             * Event handler for 'doubletap'\n             * @param event\n             */\n            handleDoubleTap: function handleDoubleTap(event) {\n                var center = this.getTouches(event)[0],\n                    zoomFactor = this.zoomFactor > 1 ? 1 : this.options.tapZoomFactor,\n                    startZoomFactor = this.zoomFactor,\n                    updateProgress = function (progress) {\n                    this.scaleTo(startZoomFactor + progress * (zoomFactor - startZoomFactor), center);\n                }.bind(this);\n\n                if (this.hasInteraction) {\n                    return;\n                }\n                if (startZoomFactor > zoomFactor) {\n                    center = this.getCurrentZoomCenter();\n                }\n\n                this.animate(this.options.animationDuration, updateProgress, this.swing);\n                triggerEvent(this.el, this.options.doubleTapEventName);\n            },\n\n            /**\n             * Max / min values for the offset\n             * @param offset\n             * @return {Object} the sanitized offset\n             */\n            sanitizeOffset: function sanitizeOffset(offset) {\n                var maxX = (this.zoomFactor - 1) * this.getContainerX(),\n                    maxY = (this.zoomFactor - 1) * this.getContainerY(),\n                    maxOffsetX = Math.max(maxX, 0),\n                    maxOffsetY = Math.max(maxY, 0),\n                    minOffsetX = Math.min(maxX, 0),\n                    minOffsetY = Math.min(maxY, 0);\n\n                return {\n                    x: Math.min(Math.max(offset.x, minOffsetX), maxOffsetX),\n                    y: Math.min(Math.max(offset.y, minOffsetY), maxOffsetY)\n                };\n            },\n\n            /**\n             * Scale to a specific zoom factor (not relative)\n             * @param zoomFactor\n             * @param center\n             */\n            scaleTo: function scaleTo(zoomFactor, center) {\n                this.scale(zoomFactor / this.zoomFactor, center);\n            },\n\n            /**\n             * Scales the element from specified center\n             * @param scale\n             * @param center\n             */\n            scale: function scale(_scale, center) {\n                _scale = this.scaleZoomFactor(_scale);\n                this.addOffset({\n                    x: (_scale - 1) * (center.x + this.offset.x),\n                    y: (_scale - 1) * (center.y + this.offset.y)\n                });\n            },\n\n            /**\n             * Scales the zoom factor relative to current state\n             * @param scale\n             * @return the actual scale (can differ because of max min zoom factor)\n             */\n            scaleZoomFactor: function scaleZoomFactor(scale) {\n                var originalZoomFactor = this.zoomFactor;\n                this.zoomFactor *= scale;\n                this.zoomFactor = Math.min(this.options.maxZoom, Math.max(this.zoomFactor, this.options.minZoom));\n                return this.zoomFactor / originalZoomFactor;\n            },\n\n            /**\n             * Drags the element\n             * @param center\n             * @param lastCenter\n             */\n            drag: function drag(center, lastCenter) {\n                if (lastCenter) {\n                    if (this.options.lockDragAxis) {\n                        // lock scroll to position that was changed the most\n                        if (Math.abs(center.x - lastCenter.x) > Math.abs(center.y - lastCenter.y)) {\n                            this.addOffset({\n                                x: -(center.x - lastCenter.x),\n                                y: 0\n                            });\n                        } else {\n                            this.addOffset({\n                                y: -(center.y - lastCenter.y),\n                                x: 0\n                            });\n                        }\n                    } else {\n                        this.addOffset({\n                            y: -(center.y - lastCenter.y),\n                            x: -(center.x - lastCenter.x)\n                        });\n                    }\n                }\n            },\n\n            /**\n             * Calculates the touch center of multiple touches\n             * @param touches\n             * @return {Object}\n             */\n            getTouchCenter: function getTouchCenter(touches) {\n                return this.getVectorAvg(touches);\n            },\n\n            /**\n             * Calculates the average of multiple vectors (x, y values)\n             */\n            getVectorAvg: function getVectorAvg(vectors) {\n                return {\n                    x: vectors.map(function (v) {\n                        return v.x;\n                    }).reduce(sum) / vectors.length,\n                    y: vectors.map(function (v) {\n                        return v.y;\n                    }).reduce(sum) / vectors.length\n                };\n            },\n\n            /**\n             * Adds an offset\n             * @param offset the offset to add\n             * @return return true when the offset change was accepted\n             */\n            addOffset: function addOffset(offset) {\n                this.offset = {\n                    x: this.offset.x + offset.x,\n                    y: this.offset.y + offset.y\n                };\n            },\n\n            sanitize: function sanitize() {\n                if (this.zoomFactor < this.options.zoomOutFactor) {\n                    this.zoomOutAnimation();\n                } else if (this.isInsaneOffset(this.offset)) {\n                    this.sanitizeOffsetAnimation();\n                }\n            },\n\n            /**\n             * Checks if the offset is ok with the current zoom factor\n             * @param offset\n             * @return {Boolean}\n             */\n            isInsaneOffset: function isInsaneOffset(offset) {\n                var sanitizedOffset = this.sanitizeOffset(offset);\n                return sanitizedOffset.x !== offset.x || sanitizedOffset.y !== offset.y;\n            },\n\n            /**\n             * Creates an animation moving to a sane offset\n             */\n            sanitizeOffsetAnimation: function sanitizeOffsetAnimation() {\n                var targetOffset = this.sanitizeOffset(this.offset),\n                    startOffset = {\n                    x: this.offset.x,\n                    y: this.offset.y\n                },\n                    updateProgress = function (progress) {\n                    this.offset.x = startOffset.x + progress * (targetOffset.x - startOffset.x);\n                    this.offset.y = startOffset.y + progress * (targetOffset.y - startOffset.y);\n                    this.update();\n                }.bind(this);\n\n                this.animate(this.options.animationDuration, updateProgress, this.swing);\n            },\n\n            /**\n             * Zooms back to the original position,\n             * (no offset and zoom factor 1)\n             */\n            zoomOutAnimation: function zoomOutAnimation() {\n                var startZoomFactor = this.zoomFactor,\n                    zoomFactor = 1,\n                    center = this.getCurrentZoomCenter(),\n                    updateProgress = function (progress) {\n                    this.scaleTo(startZoomFactor + progress * (zoomFactor - startZoomFactor), center);\n                }.bind(this);\n\n                this.animate(this.options.animationDuration, updateProgress, this.swing);\n            },\n\n            /**\n             * Updates the aspect ratio\n             */\n            updateAspectRatio: function updateAspectRatio() {\n                this.setContainerY(this.getContainerX() / this.getAspectRatio());\n            },\n\n            /**\n             * Calculates the initial zoom factor (for the element to fit into the container)\n             * @return the initial zoom factor\n             */\n            getInitialZoomFactor: function getInitialZoomFactor() {\n                return this.container.offsetWidth / this.el.offsetWidth;\n            },\n\n            /**\n             * Calculates the aspect ratio of the element\n             * @return the aspect ratio\n             */\n            getAspectRatio: function getAspectRatio() {\n                return this.el.offsetWidth / this.el.offsetHeight;\n            },\n\n            /**\n             * Calculates the virtual zoom center for the current offset and zoom factor\n             * (used for reverse zoom)\n             * @return {Object} the current zoom center\n             */\n            getCurrentZoomCenter: function getCurrentZoomCenter() {\n\n                // uses following formula to calculate the zoom center x value\n                // offset_left / offset_right = zoomcenter_x / (container_x - zoomcenter_x)\n                var length = this.container.offsetWidth * this.zoomFactor,\n                    offsetLeft = this.offset.x,\n                    offsetRight = length - offsetLeft - this.container.offsetWidth,\n                    widthOffsetRatio = offsetLeft / offsetRight,\n                    centerX = widthOffsetRatio * this.container.offsetWidth / (widthOffsetRatio + 1),\n\n\n                // the same for the zoomcenter y\n                height = this.container.offsetHeight * this.zoomFactor,\n                    offsetTop = this.offset.y,\n                    offsetBottom = height - offsetTop - this.container.offsetHeight,\n                    heightOffsetRatio = offsetTop / offsetBottom,\n                    centerY = heightOffsetRatio * this.container.offsetHeight / (heightOffsetRatio + 1);\n\n                // prevents division by zero\n                if (offsetRight === 0) {\n                    centerX = this.container.offsetWidth;\n                }\n                if (offsetBottom === 0) {\n                    centerY = this.container.offsetHeight;\n                }\n\n                return {\n                    x: centerX,\n                    y: centerY\n                };\n            },\n\n            canDrag: function canDrag() {\n                return !isCloseTo(this.zoomFactor, 1);\n            },\n\n            /**\n             * Returns the touches of an event relative to the container offset\n             * @param event\n             * @return array touches\n             */\n            getTouches: function getTouches(event) {\n                var rect = this.container.getBoundingClientRect();\n                var posTop = rect.top + document.body.scrollTop;\n                var posLeft = rect.left + document.body.scrollLeft;\n\n                return Array.prototype.slice.call(event.touches).map(function (touch) {\n                    return {\n                        x: touch.pageX - posLeft,\n                        y: touch.pageY - posTop\n                    };\n                });\n            },\n\n            /**\n             * Animation loop\n             * does not support simultaneous animations\n             * @param duration\n             * @param framefn\n             * @param timefn\n             * @param callback\n             */\n            animate: function animate(duration, framefn, timefn, callback) {\n                var startTime = new Date().getTime(),\n                    renderFrame = function () {\n                    if (!this.inAnimation) {\n                        return;\n                    }\n                    var frameTime = new Date().getTime() - startTime,\n                        progress = frameTime / duration;\n                    if (frameTime >= duration) {\n                        framefn(1);\n                        if (callback) {\n                            callback();\n                        }\n                        this.update();\n                        this.stopAnimation();\n                        this.update();\n                    } else {\n                        if (timefn) {\n                            progress = timefn(progress);\n                        }\n                        framefn(progress);\n                        this.update();\n                        requestAnimationFrame(renderFrame);\n                    }\n                }.bind(this);\n                this.inAnimation = true;\n                requestAnimationFrame(renderFrame);\n            },\n\n            /**\n             * Stops the animation\n             */\n            stopAnimation: function stopAnimation() {\n                this.inAnimation = false;\n            },\n\n            /**\n             * Swing timing function for animations\n             * @param p\n             * @return {Number}\n             */\n            swing: function swing(p) {\n                return -Math.cos(p * Math.PI) / 2 + 0.5;\n            },\n\n            getContainerX: function getContainerX() {\n                return this.container.offsetWidth;\n            },\n\n            getContainerY: function getContainerY() {\n                return this.container.offsetHeight;\n            },\n\n            setContainerY: function setContainerY(y) {\n                return this.container.style.height = y + 'px';\n            },\n\n            /**\n             * Creates the expected html structure\n             */\n            setupMarkup: function setupMarkup() {\n                this.container = buildElement('<div class=\"pinch-zoom-container\"></div>');\n                this.el.parentNode.insertBefore(this.container, this.el);\n                this.container.appendChild(this.el);\n\n                this.container.style.overflow = 'hidden';\n                this.container.style.position = 'relative';\n\n                this.el.style.webkitTransformOrigin = '0% 0%';\n                this.el.style.mozTransformOrigin = '0% 0%';\n                this.el.style.msTransformOrigin = '0% 0%';\n                this.el.style.oTransformOrigin = '0% 0%';\n                this.el.style.transformOrigin = '0% 0%';\n\n                this.el.style.position = 'absolute';\n            },\n\n            end: function end() {\n                this.hasInteraction = false;\n                this.sanitize();\n                this.update();\n            },\n\n            /**\n             * Binds all required event listeners\n             */\n            bindEvents: function bindEvents() {\n                var self = this;\n                detectGestures(this.container, this);\n\n                window.addEventListener('resize', this.update.bind(this));\n                __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from___default()(this.el.querySelectorAll('img')).forEach(function (imgEl) {\n                    imgEl.addEventListener('load', self.update.bind(self));\n                });\n\n                if (this.el.nodeName === 'IMG') {\n                    this.el.addEventListener('load', this.update.bind(this));\n                }\n            },\n\n            /**\n             * Updates the css values according to the current zoom factor and offset\n             */\n            update: function update() {\n                if (this.updatePlaned) {\n                    return;\n                }\n                this.updatePlaned = true;\n\n                setTimeout(function () {\n                    this.updatePlaned = false;\n                    this.updateAspectRatio();\n\n                    var zoomFactor = this.getInitialZoomFactor() * this.zoomFactor,\n                        offsetX = -this.offset.x / zoomFactor,\n                        offsetY = -this.offset.y / zoomFactor,\n                        transform3d = 'scale3d(' + zoomFactor + ', ' + zoomFactor + ',1) ' + 'translate3d(' + offsetX + 'px,' + offsetY + 'px,0px)',\n                        transform2d = 'scale(' + zoomFactor + ', ' + zoomFactor + ') ' + 'translate(' + offsetX + 'px,' + offsetY + 'px)',\n                        removeClone = function () {\n                        if (this.clone) {\n                            this.clone.parentNode.removeChild(this.clone);\n                            delete this.clone;\n                        }\n                    }.bind(this);\n\n                    // Scale 3d and translate3d are faster (at least on ios)\n                    // but they also reduce the quality.\n                    // PinchZoom uses the 3d transformations during interactions\n                    // after interactions it falls back to 2d transformations\n                    if (!this.options.use2d || this.hasInteraction || this.inAnimation) {\n                        this.is3d = true;\n                        removeClone();\n\n                        this.el.style.webkitTransform = transform3d;\n                        this.el.style.mozTransform = transform2d;\n                        this.el.style.msTransform = transform2d;\n                        this.el.style.oTransform = transform2d;\n                        this.el.style.transform = transform3d;\n                    } else {\n                        // When changing from 3d to 2d transform webkit has some glitches.\n                        // To avoid this, a copy of the 3d transformed element is displayed in the\n                        // foreground while the element is converted from 3d to 2d transform\n                        if (this.is3d) {\n                            this.clone = this.el.cloneNode(true);\n                            this.clone.style.pointerEvents = 'none';\n                            this.container.appendChild(this.clone);\n                            setTimeout(removeClone, 200);\n                        }\n\n                        this.el.style.webkitTransform = transform2d;\n                        this.el.style.mozTransform = transform2d;\n                        this.el.style.msTransform = transform2d;\n                        this.el.style.oTransform = transform2d;\n                        this.el.style.transform = transform2d;\n\n                        this.is3d = false;\n                    }\n                }.bind(this), 0);\n            },\n\n            /**\n             * Enables event handling for gestures\n             */\n            enable: function enable() {\n                this.enabled = true;\n            },\n\n            /**\n             * Disables event handling for gestures\n             */\n            disable: function disable() {\n                this.enabled = false;\n            }\n        };\n\n        var detectGestures = function detectGestures(el, target) {\n            var interaction = null,\n                fingers = 0,\n                lastTouchStart = null,\n                startTouches = null,\n                setInteraction = function setInteraction(newInteraction, event) {\n                if (interaction !== newInteraction) {\n\n                    if (interaction && !newInteraction) {\n                        switch (interaction) {\n                            case \"zoom\":\n                                target.handleZoomEnd(event);\n                                break;\n                            case 'drag':\n                                target.handleDragEnd(event);\n                                break;\n                        }\n                    }\n\n                    switch (newInteraction) {\n                        case 'zoom':\n                            target.handleZoomStart(event);\n                            break;\n                        case 'drag':\n                            target.handleDragStart(event);\n                            break;\n                    }\n                }\n                interaction = newInteraction;\n            },\n                updateInteraction = function updateInteraction(event) {\n                if (fingers === 2) {\n                    setInteraction('zoom');\n                } else if (fingers === 1 && target.canDrag()) {\n                    setInteraction('drag', event);\n                } else {\n                    setInteraction(null, event);\n                }\n            },\n                targetTouches = function targetTouches(touches) {\n                return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from___default()(touches).map(function (touch) {\n                    return {\n                        x: touch.pageX,\n                        y: touch.pageY\n                    };\n                });\n            },\n                getDistance = function getDistance(a, b) {\n                var x, y;\n                x = a.x - b.x;\n                y = a.y - b.y;\n                return Math.sqrt(x * x + y * y);\n            },\n                calculateScale = function calculateScale(startTouches, endTouches) {\n                var startDistance = getDistance(startTouches[0], startTouches[1]),\n                    endDistance = getDistance(endTouches[0], endTouches[1]);\n                return endDistance / startDistance;\n            },\n                cancelEvent = function cancelEvent(event) {\n                event.stopPropagation();\n                event.preventDefault();\n            },\n                detectDoubleTap = function detectDoubleTap(event) {\n                var time = new Date().getTime();\n\n                if (fingers > 1) {\n                    lastTouchStart = null;\n                }\n\n                if (time - lastTouchStart < 300) {\n                    cancelEvent(event);\n\n                    target.handleDoubleTap(event);\n                    switch (interaction) {\n                        case \"zoom\":\n                            target.handleZoomEnd(event);\n                            break;\n                        case 'drag':\n                            target.handleDragEnd(event);\n                            break;\n                    }\n                }\n\n                if (fingers === 1) {\n                    lastTouchStart = time;\n                }\n            },\n                firstMove = true;\n\n            el.addEventListener('touchstart', function (event) {\n                if (target.enabled) {\n                    firstMove = true;\n                    fingers = event.touches.length;\n                    detectDoubleTap(event);\n                }\n            });\n\n            el.addEventListener('touchmove', function (event) {\n                if (target.enabled) {\n                    if (firstMove) {\n                        updateInteraction(event);\n                        if (interaction) {\n                            cancelEvent(event);\n                        }\n                        startTouches = targetTouches(event.touches);\n                    } else {\n                        switch (interaction) {\n                            case 'zoom':\n                                target.handleZoom(event, calculateScale(startTouches, targetTouches(event.touches)));\n                                break;\n                            case 'drag':\n                                target.handleDrag(event);\n                                break;\n                        }\n                        if (interaction) {\n                            cancelEvent(event);\n                            target.update();\n                        }\n                    }\n\n                    firstMove = false;\n                }\n            });\n\n            el.addEventListener('touchend', function (event) {\n                if (target.enabled) {\n                    fingers = event.touches.length;\n                    updateInteraction(event);\n                }\n            });\n        };\n\n        return PinchZoom;\n    };\n\n    if (typeof define !== 'undefined' && __webpack_require__(1662)) {\n        define(function () {\n            return definePinchZoom();\n        });\n    } else {\n        window.PinchZoom = definePinchZoom();\n    }\n}).call(this);\n\n\n\n/***/ }),\n\n/***/ 1432:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assets_pinchzoom_js__ = __webpack_require__(1407);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* unused harmony default export */ var _unused_webpack_default_export = ({\n   data: function data() {\n      return {\n         \"imgUrl\": \"\"\n      };\n   },\n   created: function created() {\n      var id = this.$route.params.id;\n      var type = this.$route.params.type;\n      var url = _baseUrl + \"/bpm/activiti/processImage.do?\";\n      switch (type) {\n         case \"task\":\n            url += \"taskId=\";\n            break;\n         case \"inst\":\n            url += \"instId=\";\n            break;\n         case \"start\":\n            url += \"actDefId=\";\n            break;\n      }\n      //url+=(type==\"task\") ? \"taskId=\" : \"instId=\";\n      url += id;\n      this.imgUrl = url;\n\n      this.$dialog.loading.open('正在加载流程图,请稍候...');\n   },\n   mounted: function mounted() {\n      var _this = this;\n\n      var el = document.getElementById('processImg');\n      var pz = new __WEBPACK_IMPORTED_MODULE_0__assets_pinchzoom_js__[\"a\" /* PinchZoom */](el);\n\n      el.onload = function () {\n         _this.$dialog.loading.close();\n      };\n   }\n});\n\n/***/ }),\n\n/***/ 1478:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assets_pinchzoom_js__ = __webpack_require__(1407);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n   data: function data() {\n      return {\n         \"imgUrl\": \"\"\n      };\n   },\n   created: function created() {\n      var id = this.$route.params.id;\n      var type = this.$route.params.type;\n      var url = _baseUrl + \"/bpm/activiti/processImage.do?\";\n      switch (type) {\n         case \"task\":\n            url += \"taskId=\";\n            break;\n         case \"inst\":\n            url += \"instId=\";\n            break;\n         case \"start\":\n            url += \"actDefId=\";\n            break;\n      }\n      //url+=(type==\"task\") ? \"taskId=\" : \"instId=\";\n      url += id;\n      this.imgUrl = url;\n\n      this.$dialog.loading.open('正在加载流程图,请稍候...');\n   },\n   mounted: function mounted() {\n      var _this = this;\n\n      var el = document.getElementById('processImg');\n      var pz = new __WEBPACK_IMPORTED_MODULE_0__assets_pinchzoom_js__[\"a\" /* PinchZoom */](el);\n\n      el.onload = function () {\n         _this.$dialog.loading.close();\n      };\n   }\n});\n\n/***/ }),\n\n/***/ 1532:\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(327)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"#scrollView .pinch-zoom-container{height:100%!important}\", \"\", {\"version\":3,\"sources\":[\"E:/work/redxun/mobile/mobile/src/components/bpm/FlowImage.vue\"],\"names\":[],\"mappings\":\"AACA,kCAEC,qBAAwB,CACxB\",\"file\":\"FlowImage.vue\",\"sourcesContent\":[\"\\n#scrollView .pinch-zoom-container{\\n\\t/*box-sizing: border-box;*/\\n\\theight: 100% !important;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ 1579:\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(1532);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(1169)(\"36aad0a8\", content, true);\n\n/***/ }),\n\n/***/ 1627:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('yd-layout',[_c('yd-navbar',{attrs:{\"slot\":\"navbar\",\"title\":\"流程图\"},slot:\"navbar\"},[_c('a',{attrs:{\"slot\":\"left\",\"href\":\"javascript:;\"},on:{\"click\":_vm.goBack},slot:\"left\"},[_c('yd-navbar-back-icon')],1)]),_vm._v(\" \"),_c('img',{attrs:{\"src\":_vm.imgUrl,\"id\":\"processImg\"}})],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ 1662:\n/***/ (function(module, exports) {\n\n/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/22.a28cf9a012b130059b37.js","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-356ea82c\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../node_modules/vux-loader/src/style-loader.js!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./FlowImage.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./FlowImage.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vux-loader/src/script-loader.js!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./FlowImage.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-356ea82c\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vux-loader/src/before-template-compiler-loader.js!../../../node_modules/vux-loader/src/template-loader.js!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./FlowImage.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/bpm/FlowImage.vue\n// module id = 1175\n// module chunks = 22","/*global console, define, setTimeout, window*/\n(function () {\n    'use strict';\n\n    // polyfills\n    if (typeof Object.assign != 'function') {\n      // Must be writable: true, enumerable: false, configurable: true\n      Object.defineProperty(Object, \"assign\", {\n        value: function assign(target, varArgs) { // .length of function is 2\n          if (target == null) { // TypeError if undefined or null\n            throw new TypeError('Cannot convert undefined or null to object');\n          }\n\n          var to = Object(target);\n\n          for (var index = 1; index < arguments.length; index++) {\n            var nextSource = arguments[index];\n\n            if (nextSource != null) { // Skip over if undefined or null\n              for (var nextKey in nextSource) {\n                // Avoid bugs when hasOwnProperty is shadowed\n                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                  to[nextKey] = nextSource[nextKey];\n                }\n              }\n            }\n          }\n          return to;\n        },\n        writable: true,\n        configurable: true\n      });\n    }\n\n    if (typeof Array.from != 'function') {\n      Array.from = function (object) {\n        return [].slice.call(object);\n      };\n    }\n\n    // utils\n    var buildElement = function(str) {\n      // empty string as title argument required by IE and Edge\n      var tmp = document.implementation.createHTMLDocument('');\n      tmp.body.innerHTML = str;\n      return Array.from(tmp.body.children)[0];\n    };\n\n    var triggerEvent = function(el, name) {\n      var event = document.createEvent('HTMLEvents');\n      event.initEvent(name, true, false);\n      el.dispatchEvent(event);\n    };\n\n    var definePinchZoom = function () {\n\n        /**\n         * Pinch zoom\n         * @version 2.0.0\n         * @author Manuel Stofer <mst@rtp.ch>\n         * @param el\n         * @param options\n         * @constructor\n         */\n        var PinchZoom = function (el, options) {\n                this.el = el;\n                this.zoomFactor = 1;\n                this.lastScale = 1;\n                this.offset = {\n                    x: 0,\n                    y: 0\n                };\n                this.options = Object.assign({}, this.defaults, options);\n                this.setupMarkup();\n                this.bindEvents();\n                this.update();\n                // default enable.\n                this.enable();\n\n            },\n            sum = function (a, b) {\n                return a + b;\n            },\n            isCloseTo = function (value, expected) {\n                return value > expected - 0.01 && value < expected + 0.01;\n            };\n\n        PinchZoom.prototype = {\n\n            defaults: {\n                tapZoomFactor: 2,\n                zoomOutFactor: 1.3,\n                animationDuration: 300,\n                maxZoom: 4,\n                minZoom: 0.5,\n                lockDragAxis: false,\n                use2d: true,\n                zoomStartEventName: 'pz_zoomstart',\n                zoomEndEventName: 'pz_zoomend',\n                dragStartEventName: 'pz_dragstart',\n                dragEndEventName: 'pz_dragend',\n                doubleTapEventName: 'pz_doubletap'\n            },\n\n            /**\n             * Event handler for 'dragstart'\n             * @param event\n             */\n            handleDragStart: function (event) {\n                triggerEvent(this.el, this.options.dragStartEventName);\n                this.stopAnimation();\n                this.lastDragPosition = false;\n                this.hasInteraction = true;\n                this.handleDrag(event);\n            },\n\n            /**\n             * Event handler for 'drag'\n             * @param event\n             */\n            handleDrag: function (event) {\n                if (this.zoomFactor > 1.0) {\n                    var touch = this.getTouches(event)[0];\n                    this.drag(touch, this.lastDragPosition);\n                    this.offset = this.sanitizeOffset(this.offset);\n                    this.lastDragPosition = touch;\n                }\n            },\n\n            handleDragEnd: function () {\n                triggerEvent(this.el, this.options.dragEndEventName);\n                this.end();\n            },\n\n            /**\n             * Event handler for 'zoomstart'\n             * @param event\n             */\n            handleZoomStart: function (event) {\n                triggerEvent(this.el, this.options.zoomStartEventName);\n                this.stopAnimation();\n                this.lastScale = 1;\n                this.nthZoom = 0;\n                this.lastZoomCenter = false;\n                this.hasInteraction = true;\n            },\n\n            /**\n             * Event handler for 'zoom'\n             * @param event\n             */\n            handleZoom: function (event, newScale) {\n                // a relative scale factor is used\n                var touchCenter = this.getTouchCenter(this.getTouches(event)),\n                    scale = newScale / this.lastScale;\n                this.lastScale = newScale;\n\n                // the first touch events are thrown away since they are not precise\n                this.nthZoom += 1;\n                if (this.nthZoom > 3) {\n\n                    this.scale(scale, touchCenter);\n                    this.drag(touchCenter, this.lastZoomCenter);\n                }\n                this.lastZoomCenter = touchCenter;\n            },\n\n            handleZoomEnd: function () {\n                triggerEvent(this.el, this.options.zoomEndEventName);\n                this.end();\n            },\n\n            /**\n             * Event handler for 'doubletap'\n             * @param event\n             */\n            handleDoubleTap: function (event) {\n                var center = this.getTouches(event)[0],\n                    zoomFactor = this.zoomFactor > 1 ? 1 : this.options.tapZoomFactor,\n                    startZoomFactor = this.zoomFactor,\n                    updateProgress = (function (progress) {\n                        this.scaleTo(startZoomFactor + progress * (zoomFactor - startZoomFactor), center);\n                    }).bind(this);\n\n                if (this.hasInteraction) {\n                    return;\n                }\n                if (startZoomFactor > zoomFactor) {\n                    center = this.getCurrentZoomCenter();\n                }\n\n                this.animate(this.options.animationDuration, updateProgress, this.swing);\n                triggerEvent(this.el, this.options.doubleTapEventName);\n            },\n\n            /**\n             * Max / min values for the offset\n             * @param offset\n             * @return {Object} the sanitized offset\n             */\n            sanitizeOffset: function (offset) {\n                var maxX = (this.zoomFactor - 1) * this.getContainerX(),\n                    maxY = (this.zoomFactor - 1) * this.getContainerY(),\n                    maxOffsetX = Math.max(maxX, 0),\n                    maxOffsetY = Math.max(maxY, 0),\n                    minOffsetX = Math.min(maxX, 0),\n                    minOffsetY = Math.min(maxY, 0);\n\n                return {\n                    x: Math.min(Math.max(offset.x, minOffsetX), maxOffsetX),\n                    y: Math.min(Math.max(offset.y, minOffsetY), maxOffsetY)\n                };\n            },\n\n            /**\n             * Scale to a specific zoom factor (not relative)\n             * @param zoomFactor\n             * @param center\n             */\n            scaleTo: function (zoomFactor, center) {\n                this.scale(zoomFactor / this.zoomFactor, center);\n            },\n\n            /**\n             * Scales the element from specified center\n             * @param scale\n             * @param center\n             */\n            scale: function (scale, center) {\n                scale = this.scaleZoomFactor(scale);\n                this.addOffset({\n                    x: (scale - 1) * (center.x + this.offset.x),\n                    y: (scale - 1) * (center.y + this.offset.y)\n                });\n            },\n\n            /**\n             * Scales the zoom factor relative to current state\n             * @param scale\n             * @return the actual scale (can differ because of max min zoom factor)\n             */\n            scaleZoomFactor: function (scale) {\n                var originalZoomFactor = this.zoomFactor;\n                this.zoomFactor *= scale;\n                this.zoomFactor = Math.min(this.options.maxZoom, Math.max(this.zoomFactor, this.options.minZoom));\n                return this.zoomFactor / originalZoomFactor;\n            },\n\n            /**\n             * Drags the element\n             * @param center\n             * @param lastCenter\n             */\n            drag: function (center, lastCenter) {\n                if (lastCenter) {\n                  if(this.options.lockDragAxis) {\n                    // lock scroll to position that was changed the most\n                    if(Math.abs(center.x - lastCenter.x) > Math.abs(center.y - lastCenter.y)) {\n                      this.addOffset({\n                        x: -(center.x - lastCenter.x),\n                        y: 0\n                      });\n                    }\n                    else {\n                      this.addOffset({\n                        y: -(center.y - lastCenter.y),\n                        x: 0\n                      });\n                    }\n                  }\n                  else {\n                    this.addOffset({\n                      y: -(center.y - lastCenter.y),\n                      x: -(center.x - lastCenter.x)\n                    });\n                  }\n                }\n            },\n\n            /**\n             * Calculates the touch center of multiple touches\n             * @param touches\n             * @return {Object}\n             */\n            getTouchCenter: function (touches) {\n                return this.getVectorAvg(touches);\n            },\n\n            /**\n             * Calculates the average of multiple vectors (x, y values)\n             */\n            getVectorAvg: function (vectors) {\n                return {\n                    x: vectors.map(function (v) { return v.x; }).reduce(sum) / vectors.length,\n                    y: vectors.map(function (v) { return v.y; }).reduce(sum) / vectors.length\n                };\n            },\n\n            /**\n             * Adds an offset\n             * @param offset the offset to add\n             * @return return true when the offset change was accepted\n             */\n            addOffset: function (offset) {\n                this.offset = {\n                    x: this.offset.x + offset.x,\n                    y: this.offset.y + offset.y\n                };\n            },\n\n            sanitize: function () {\n                if (this.zoomFactor < this.options.zoomOutFactor) {\n                    this.zoomOutAnimation();\n                } else if (this.isInsaneOffset(this.offset)) {\n                    this.sanitizeOffsetAnimation();\n                }\n            },\n\n            /**\n             * Checks if the offset is ok with the current zoom factor\n             * @param offset\n             * @return {Boolean}\n             */\n            isInsaneOffset: function (offset) {\n                var sanitizedOffset = this.sanitizeOffset(offset);\n                return sanitizedOffset.x !== offset.x ||\n                    sanitizedOffset.y !== offset.y;\n            },\n\n            /**\n             * Creates an animation moving to a sane offset\n             */\n            sanitizeOffsetAnimation: function () {\n                var targetOffset = this.sanitizeOffset(this.offset),\n                    startOffset = {\n                        x: this.offset.x,\n                        y: this.offset.y\n                    },\n                    updateProgress = (function (progress) {\n                        this.offset.x = startOffset.x + progress * (targetOffset.x - startOffset.x);\n                        this.offset.y = startOffset.y + progress * (targetOffset.y - startOffset.y);\n                        this.update();\n                    }).bind(this);\n\n                this.animate(\n                    this.options.animationDuration,\n                    updateProgress,\n                    this.swing\n                );\n            },\n\n            /**\n             * Zooms back to the original position,\n             * (no offset and zoom factor 1)\n             */\n            zoomOutAnimation: function () {\n                var startZoomFactor = this.zoomFactor,\n                    zoomFactor = 1,\n                    center = this.getCurrentZoomCenter(),\n                    updateProgress = (function (progress) {\n                        this.scaleTo(startZoomFactor + progress * (zoomFactor - startZoomFactor), center);\n                    }).bind(this);\n\n                this.animate(\n                    this.options.animationDuration,\n                    updateProgress,\n                    this.swing\n                );\n            },\n\n            /**\n             * Updates the aspect ratio\n             */\n            updateAspectRatio: function () {\n                this.setContainerY(this.getContainerX() / this.getAspectRatio());\n            },\n\n            /**\n             * Calculates the initial zoom factor (for the element to fit into the container)\n             * @return the initial zoom factor\n             */\n            getInitialZoomFactor: function () {\n                return this.container.offsetWidth / this.el.offsetWidth;\n            },\n\n            /**\n             * Calculates the aspect ratio of the element\n             * @return the aspect ratio\n             */\n            getAspectRatio: function () {\n                return this.el.offsetWidth / this.el.offsetHeight;\n            },\n\n            /**\n             * Calculates the virtual zoom center for the current offset and zoom factor\n             * (used for reverse zoom)\n             * @return {Object} the current zoom center\n             */\n            getCurrentZoomCenter: function () {\n\n                // uses following formula to calculate the zoom center x value\n                // offset_left / offset_right = zoomcenter_x / (container_x - zoomcenter_x)\n                var length = this.container.offsetWidth * this.zoomFactor,\n                    offsetLeft  = this.offset.x,\n                    offsetRight = length - offsetLeft - this.container.offsetWidth,\n                    widthOffsetRatio = offsetLeft / offsetRight,\n                    centerX = widthOffsetRatio * this.container.offsetWidth / (widthOffsetRatio + 1),\n\n                // the same for the zoomcenter y\n                    height = this.container.offsetHeight * this.zoomFactor,\n                    offsetTop  = this.offset.y,\n                    offsetBottom = height - offsetTop - this.container.offsetHeight,\n                    heightOffsetRatio = offsetTop / offsetBottom,\n                    centerY = heightOffsetRatio * this.container.offsetHeight / (heightOffsetRatio + 1);\n\n                // prevents division by zero\n                if (offsetRight === 0) { centerX = this.container.offsetWidth; }\n                if (offsetBottom === 0) { centerY = this.container.offsetHeight; }\n\n                return {\n                    x: centerX,\n                    y: centerY\n                };\n            },\n\n            canDrag: function () {\n                return !isCloseTo(this.zoomFactor, 1);\n            },\n\n            /**\n             * Returns the touches of an event relative to the container offset\n             * @param event\n             * @return array touches\n             */\n            getTouches: function (event) {\n                var rect = this.container.getBoundingClientRect();\n                var posTop = rect.top + document.body.scrollTop;\n                var posLeft = rect.left + document.body.scrollLeft;\n\n                return Array.prototype.slice.call(event.touches).map(function (touch) {\n                    return {\n                        x: touch.pageX - posLeft,\n                        y: touch.pageY - posTop,\n                    };\n                });\n            },\n\n            /**\n             * Animation loop\n             * does not support simultaneous animations\n             * @param duration\n             * @param framefn\n             * @param timefn\n             * @param callback\n             */\n            animate: function (duration, framefn, timefn, callback) {\n                var startTime = new Date().getTime(),\n                    renderFrame = (function () {\n                        if (!this.inAnimation) { return; }\n                        var frameTime = new Date().getTime() - startTime,\n                            progress = frameTime / duration;\n                        if (frameTime >= duration) {\n                            framefn(1);\n                            if (callback) {\n                                callback();\n                            }\n                            this.update();\n                            this.stopAnimation();\n                            this.update();\n                        } else {\n                            if (timefn) {\n                                progress = timefn(progress);\n                            }\n                            framefn(progress);\n                            this.update();\n                            requestAnimationFrame(renderFrame);\n                        }\n                    }).bind(this);\n                this.inAnimation = true;\n                requestAnimationFrame(renderFrame);\n            },\n\n            /**\n             * Stops the animation\n             */\n            stopAnimation: function () {\n                this.inAnimation = false;\n            },\n\n            /**\n             * Swing timing function for animations\n             * @param p\n             * @return {Number}\n             */\n            swing: function (p) {\n                return -Math.cos(p * Math.PI) / 2  + 0.5;\n            },\n\n            getContainerX: function () {\n                return this.container.offsetWidth;\n            },\n\n            getContainerY: function () {\n                return this.container.offsetHeight;\n            },\n\n            setContainerY: function (y) {\n                return this.container.style.height = y + 'px';\n            },\n\n            /**\n             * Creates the expected html structure\n             */\n            setupMarkup: function () {\n                this.container = buildElement('<div class=\"pinch-zoom-container\"></div>');\n                this.el.parentNode.insertBefore(this.container, this.el);\n                this.container.appendChild(this.el);\n\n                this.container.style.overflow = 'hidden';\n                this.container.style.position = 'relative';\n\n                this.el.style.webkitTransformOrigin = '0% 0%';\n                this.el.style.mozTransformOrigin = '0% 0%';\n                this.el.style.msTransformOrigin = '0% 0%';\n                this.el.style.oTransformOrigin = '0% 0%';\n                this.el.style.transformOrigin = '0% 0%';\n\n                this.el.style.position = 'absolute';\n            },\n\n            end: function () {\n                this.hasInteraction = false;\n                this.sanitize();\n                this.update();\n            },\n\n            /**\n             * Binds all required event listeners\n             */\n            bindEvents: function () {\n                var self = this;\n                detectGestures(this.container, this);\n\n                window.addEventListener('resize', this.update.bind(this));\n                Array.from(this.el.querySelectorAll('img')).forEach(function(imgEl) {\n                  imgEl.addEventListener('load', self.update.bind(self));\n                });\n\n                if (this.el.nodeName === 'IMG') {\n                  this.el.addEventListener('load', this.update.bind(this));\n                }\n            },\n\n            /**\n             * Updates the css values according to the current zoom factor and offset\n             */\n            update: function () {\n                if (this.updatePlaned) {\n                    return;\n                }\n                this.updatePlaned = true;\n\n                setTimeout((function () {\n                    this.updatePlaned = false;\n                    this.updateAspectRatio();\n\n                    var zoomFactor = this.getInitialZoomFactor() * this.zoomFactor,\n                        offsetX = -this.offset.x / zoomFactor,\n                        offsetY = -this.offset.y / zoomFactor,\n                        transform3d =   'scale3d('     + zoomFactor + ', '  + zoomFactor + ',1) ' +\n                            'translate3d(' + offsetX    + 'px,' + offsetY    + 'px,0px)',\n                        transform2d =   'scale('       + zoomFactor + ', '  + zoomFactor + ') ' +\n                            'translate('   + offsetX    + 'px,' + offsetY    + 'px)',\n                        removeClone = (function () {\n                            if (this.clone) {\n                                this.clone.parentNode.removeChild(this.clone);\n                                delete this.clone;\n                            }\n                        }).bind(this);\n\n                    // Scale 3d and translate3d are faster (at least on ios)\n                    // but they also reduce the quality.\n                    // PinchZoom uses the 3d transformations during interactions\n                    // after interactions it falls back to 2d transformations\n                    if (!this.options.use2d || this.hasInteraction || this.inAnimation) {\n                        this.is3d = true;\n                        removeClone();\n\n                        this.el.style.webkitTransform = transform3d;\n                        this.el.style.mozTransform = transform2d;\n                        this.el.style.msTransform = transform2d;\n                        this.el.style.oTransform = transform2d;\n                        this.el.style.transform = transform3d;\n                    } else {\n                        // When changing from 3d to 2d transform webkit has some glitches.\n                        // To avoid this, a copy of the 3d transformed element is displayed in the\n                        // foreground while the element is converted from 3d to 2d transform\n                        if (this.is3d) {\n                            this.clone = this.el.cloneNode(true);\n                            this.clone.style.pointerEvents = 'none';\n                            this.container.appendChild(this.clone);\n                            setTimeout(removeClone, 200);\n                        }\n\n                        this.el.style.webkitTransform = transform2d;\n                        this.el.style.mozTransform = transform2d;\n                        this.el.style.msTransform = transform2d;\n                        this.el.style.oTransform = transform2d;\n                        this.el.style.transform = transform2d;\n\n                        this.is3d = false;\n                    }\n                }).bind(this), 0);\n            },\n\n            /**\n             * Enables event handling for gestures\n             */\n            enable: function() {\n              this.enabled = true;\n            },\n\n            /**\n             * Disables event handling for gestures\n             */\n            disable: function() {\n              this.enabled = false;\n            }\n        };\n\n        var detectGestures = function (el, target) {\n            var interaction = null,\n                fingers = 0,\n                lastTouchStart = null,\n                startTouches = null,\n\n                setInteraction = function (newInteraction, event) {\n                    if (interaction !== newInteraction) {\n\n                        if (interaction && !newInteraction) {\n                            switch (interaction) {\n                                case \"zoom\":\n                                    target.handleZoomEnd(event);\n                                    break;\n                                case 'drag':\n                                    target.handleDragEnd(event);\n                                    break;\n                            }\n                        }\n\n                        switch (newInteraction) {\n                            case 'zoom':\n                                target.handleZoomStart(event);\n                                break;\n                            case 'drag':\n                                target.handleDragStart(event);\n                                break;\n                        }\n                    }\n                    interaction = newInteraction;\n                },\n\n                updateInteraction = function (event) {\n                    if (fingers === 2) {\n                        setInteraction('zoom');\n                    } else if (fingers === 1 && target.canDrag()) {\n                        setInteraction('drag', event);\n                    } else {\n                        setInteraction(null, event);\n                    }\n                },\n\n                targetTouches = function (touches) {\n                    return Array.from(touches).map(function (touch) {\n                        return {\n                            x: touch.pageX,\n                            y: touch.pageY\n                        };\n                    });\n                },\n\n                getDistance = function (a, b) {\n                    var x, y;\n                    x = a.x - b.x;\n                    y = a.y - b.y;\n                    return Math.sqrt(x * x + y * y);\n                },\n\n                calculateScale = function (startTouches, endTouches) {\n                    var startDistance = getDistance(startTouches[0], startTouches[1]),\n                        endDistance = getDistance(endTouches[0], endTouches[1]);\n                    return endDistance / startDistance;\n                },\n\n                cancelEvent = function (event) {\n                    event.stopPropagation();\n                    event.preventDefault();\n                },\n\n                detectDoubleTap = function (event) {\n                    var time = (new Date()).getTime();\n\n                    if (fingers > 1) {\n                        lastTouchStart = null;\n                    }\n\n                    if (time - lastTouchStart < 300) {\n                        cancelEvent(event);\n\n                        target.handleDoubleTap(event);\n                        switch (interaction) {\n                            case \"zoom\":\n                                target.handleZoomEnd(event);\n                                break;\n                            case 'drag':\n                                target.handleDragEnd(event);\n                                break;\n                        }\n                    }\n\n                    if (fingers === 1) {\n                        lastTouchStart = time;\n                    }\n                },\n                firstMove = true;\n\n            el.addEventListener('touchstart', function (event) {\n                if(target.enabled) {\n                    firstMove = true;\n                    fingers = event.touches.length;\n                    detectDoubleTap(event);\n                }\n            });\n\n            el.addEventListener('touchmove', function (event) {\n                if(target.enabled) {\n                    if (firstMove) {\n                        updateInteraction(event);\n                        if (interaction) {\n                            cancelEvent(event);\n                        }\n                        startTouches = targetTouches(event.touches);\n                    } else {\n                        switch (interaction) {\n                            case 'zoom':\n                                target.handleZoom(event, calculateScale(startTouches, targetTouches(event.touches)));\n                                break;\n                            case 'drag':\n                                target.handleDrag(event);\n                                break;\n                        }\n                        if (interaction) {\n                            cancelEvent(event);\n                            target.update();\n                        }\n                    }\n\n                    firstMove = false;\n                }\n            });\n\n            el.addEventListener('touchend', function (event) {\n                if(target.enabled) {\n                    fingers = event.touches.length;\n                    updateInteraction(event);\n                }\n            });\n        };\n\n        return PinchZoom;\n    };\n\n    if (typeof define !== 'undefined' && define.amd) {\n        define(function () {\n            return definePinchZoom();\n        });\n    } else {\n        window.PinchZoom = definePinchZoom();\n    }\n}).call(this);\n\nexport {\n\tPinchZoom\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/assets/pinchzoom.js","//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\t\nimport {PinchZoom} from '@/assets/pinchzoom.js';\n\n\nexport default{\n   data() {\n      return {\n        \"imgUrl\" :\"\"\n      }\n   },\n\n   created() {\n      let id=this.$route.params.id;\n      let type=this.$route.params.type;\n      var url=_baseUrl +\"/bpm/activiti/processImage.do?\";\n      switch(type){\n      \tcase \"task\":\n      \t\turl+=\"taskId=\" ;\n      \t\tbreak;\n      \tcase \"inst\":\n      \t\turl+=\"instId=\" ; \n      \t\tbreak;\n      \tcase \"start\":\n      \t\turl+=\"actDefId=\" ; \n      \t\tbreak;\n      }\n      //url+=(type==\"task\") ? \"taskId=\" : \"instId=\";\n      url+=id;\n      this.imgUrl=url;\n      \n      this.$dialog.loading.open('正在加载流程图,请稍候...');\n      \n   },\n   mounted(){\n   \t\tlet el = document.getElementById('processImg');\n\t\t\tlet pz = new PinchZoom(el);\n\t\t\t\n\t\t\tel.onload =()=>{\n\t\t\t\tthis.$dialog.loading.close();\n\t\t\t}\n\t\t\t\n   }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/bpm/FlowImage.vue","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \"#scrollView .pinch-zoom-container{height:100%!important}\", \"\", {\"version\":3,\"sources\":[\"E:/work/redxun/mobile/mobile/src/components/bpm/FlowImage.vue\"],\"names\":[],\"mappings\":\"AACA,kCAEC,qBAAwB,CACxB\",\"file\":\"FlowImage.vue\",\"sourcesContent\":[\"\\n#scrollView .pinch-zoom-container{\\n\\t/*box-sizing: border-box;*/\\n\\theight: 100% !important;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-356ea82c\",\"scoped\":false,\"hasInlineConfig\":false}!./~/vux-loader/src/style-loader.js!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/bpm/FlowImage.vue\n// module id = 1532\n// module chunks = 22","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-356ea82c\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../node_modules/vux-loader/src/style-loader.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./FlowImage.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"36aad0a8\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-356ea82c\",\"scoped\":false,\"hasInlineConfig\":false}!./~/vux-loader/src/style-loader.js!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/bpm/FlowImage.vue\n// module id = 1579\n// module chunks = 22","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('yd-layout',[_c('yd-navbar',{attrs:{\"slot\":\"navbar\",\"title\":\"流程图\"},slot:\"navbar\"},[_c('a',{attrs:{\"slot\":\"left\",\"href\":\"javascript:;\"},on:{\"click\":_vm.goBack},slot:\"left\"},[_c('yd-navbar-back-icon')],1)]),_vm._v(\" \"),_c('img',{attrs:{\"src\":_vm.imgUrl,\"id\":\"processImg\"}})],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-356ea82c\",\"hasScoped\":false,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./~/vux-loader/src/before-template-compiler-loader.js!./~/vux-loader/src/template-loader.js!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/bpm/FlowImage.vue\n// module id = 1627\n// module chunks = 22","/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-options.js\n// module id = 1662\n// module chunks = 22"],"sourceRoot":""}